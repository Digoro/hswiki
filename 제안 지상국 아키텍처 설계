# 제안 지상국 아키텍쳐 설계
본 연구에서는 이기종 정찰위성(EO, IR, SAR 등)을 단일 지상국에서 통합 운용하기 위한 확장형 지상국 소프트웨어 아키텍처를 제안한다. 기존의 모놀리식(monolithic) 구조는 시스템 전체가 하나의 거대한 애플리케이션으로 구성되어 있어, 특정 기능 수정이나 새로운 위성 추가 시 전체 재배포가 필요하였다. 이로 인해 유지보수 비용이 증가하고, 위성별 맞춤 운용 기능의 확장이 어려웠다. 이를 해결하기 위해 본 연구는 마이크로서비스 아키텍처(MSA), 컨테이너 기반 배포 환경(Docker), 메시지 기반 통신 구조(Event-driven Architecture)를 통합 적용하였다.
## 마이크로서비스 아키텍처
==MSA 설명 그림 추가==
마이크로서비스 아키텍처(Microservice Architecture, MSA)는 시스템을 여러 개의 독립적인 서비스 단위로 분리하여 각 서비스가 독립적으로 개발, 배포, 확장될 수 있도록 하는 구조이다. 기존의 모놀리식 구조는 모든 기능이 하나의 애플리케이션 안에 통합되어 있어 일부 기능 변경에도 전체 시스템 재배포가 필요하고 장애가 전체로 확산되는 문제가 있었다. 반면 MSA는 기능 별 서비스를 분리하여 결합도를 낮추고 기능 단위의 확장성·유지보수성·복원력을 확보할 수 있다.
### 적용 예시
위성 지상국 시스템들은 기본적으로 동일한 데이터 흐름과 관리 로직을 공유하지만 위성의 센서 특성에 따라 세부 기능이 달라진다. 따라서 제안하는 구조에서는 공통 기능은 유지하고 위성 별 특화 기능만 플러그인 형태로 분리하여 추가하도록 설계할 수 있다.

• PMS: 공통적으로 정찰 위성 지상국은 영상 처리 작업에 대한 스케줄링, 처리된 영상에 대한 저장 및 조회, 처리 상태 모니터링 등의 기능을 수행한다. 그러나 위성 별, 센서 별로 처리 알고리즘(Processor)은 다르다. 이 경우 공통 서비스는 동일하게 유지하되 상이한 처리 알고리즘은 플러그인 모듈 형태로 업로드하여 적용한다. 운용자는 신규 위성 추가 시 해당 위성의 처리 플러그인만 Docker 이미지 형태로 등록하기만 하면 된다.
• MPS: 임무계획 데이터를 수신하여 검증하고 이를 명령 시퀀스로 변환한 뒤 SOS에 전달하는 프로세스는 공통적이지만 위성 별로 파일 포맷, 유효성 검증 방식, 명령 시퀀스의 변환 규칙이 다르다. 공통 임무계획 서비스는 동일하게 유지하고 위성 별 스펙과 제약조건을 반영한 검증 및 변환 모듈을 플러그인 형태로 추가만 하면 되는 방식으로 개발이 가능하다.
• SOS: 명령 송수신 기능과 상태 모니터링 기능은 공통이며, 위성 별 명령 포맷이나 텔레메트리 항목만 다르다. SOS는 위성 ICD(Interface Control Document)를 기반으로 플러그인 명령 파서 및 텔레메트리 디코더를 플러그인 형태로 등록하여 간단히 추가 할 수 있다.

이러한 방식으로 지상국 소프트웨어의 구조적 복잡성을 단순화하고 기능 간 결합도를 최소화함으로써 확장성과 유연성을 극대화하였다. 각 서비스는 독립적인 단위로 설계되어 위성 별로 상이한 알고리즘이나 운용 로직을 플러그인 형태로 손쉽게 추가할 수 있으며 시스템 전체를 재구성하지 않고도 새로운 위성 통합을 가능하게 한다.
### 제안 오프소스 및 기술 스택

| 구분          | 기술명                           | 주요 기능                   |
| ----------- | ----------------------------- | ----------------------- |
| MSA 프레임워크   | Spring Cloud, NestJS, FastAPI | REST/gRPC 기반 마이크로서비스 구현 |
| 서비스 등록/발견   | Consul, Eureka                | 신규 서비스 자동 탐색 및 로드 밸런싱   |
| API Gateway | Kong, Traefik, Nginx          | 통합 라우팅, 인증 및 보안 관리      |
| 설정 관리       | Spring Cloud Config, etcd     | 서비스 환경 설정 중앙 집중 관리      |
## 컨테이너 기반 배포 환경
==도커 설명 그림 추가==
Docker는 응용 프로그램과 실행 환경을 하나의 경량 컨테이너로 패키징하여 어디서나 동일하게 실행할 수 있게 하는 오픈소스 플랫폼이다. 가상머신(VM) 대비 빠른 시작 속도와 낮은 리소스 사용량을 가지며 마이크로서비스 아키텍처 구조에서 각 서비스를 독립적으로 배포 및 관리할 수 있도록 지원한다. 컨테이너 기술은 일관된 배포 환경, 신속한 복구, 확장 자동화 측면에서 지상국 시스템의 안정적인 운용에 적합하다.
### 적용 예시
지상국 소프트웨어는 서비스별로 이기종 언어와 하드웨어를 사용하는 복잡한 구조를 가질 수 있다. 예를 들어, 비행역학은 Python 기반, 위성운용은 Java 기반, 영상처리는 GPU 연산이 필요한 C++ 기반으로 개발될 수 있다. 이러한 이질적인 환경을 통합하기 위해 각 서비스를 Docker 컨테이너로 패키징하고 Kubernetes(K8s)를 통해 오케스트레이션한다. 시스템 부하가 증가할 경우 Kubernetes의 자동 스케일링 기능을 통해 영상처리 컨테이너만 즉시 확장하여 자원 효율을 극대화한다. 또한, 장애가 발생한 서비스 컨테이너는 자동으로 재시작되어 무중단 운용을 실현할 수도 있다.
### 제안 오프소스 및 기술 스택

| 구분       | 기술명                           | 주요 기능                   |
| -------- | ----------------------------- | ----------------------- |
| 컨테이너 런타임 | Docker, Podman                | 경량화된 컨테이너 실행 환경 제공      |
| 오케스트레이션  | Kubernetes(K8s), Docker Swarm | 서비스 자동 배포, 스케일링, 복구     |
| 이미지 저장소  | Harbor, Docker Hub            | 컨테이너 이미지 관리 및 버전 관리     |
| 모니터링     | Prometheus, Grafana           | 자원 사용량 및 상태 시각화         |
| CI/CD    | Jenkins, ArgoCD               | 자동 빌드 및 지속적 배포 파이프라인 구축 |

메시지 기반 통신 구조(Event-driven Architecture)는 서비스 간 직접 호출 대신 메시지 브로커(Message Broker) 를 매개로 하여 비동기적으로 이벤트를 전달하는 구조이다.
각 서비스는 이벤트를 발행(Publish)하거나 구독(Subscribe)하는 방식으로 동작하며, 이를 통해 서비스 간 결합도를 최소화할 수 있다.
직접 호출 방식에서는 서비스 간 인터페이스 변경이 전체 시스템에 영향을 미칠 수 있으나, 메시지 기반 구조에서는 이벤트의 형식만 유지되면 신규 서비스 추가나 수정이 기존 서비스에 영향을 주지 않는다.
따라서 각 서비스는 독립적으로 개발·운용되면서도, 메시지 구독 설정만으로 손쉽게 상호 연동이 가능하다.
이 방식은 서비스 간 연동을 단순화하고, 장애나 지연이 발생하더라도 전체 시스템의 운용이 중단되지 않는 내결함성(Fault Tolerance) 과 확장성(Scalability) 을 동시에 확보한다.

적용 예시

지상국 소프트웨어는 다음과 같은 이벤트 중심의 데이터 흐름으로 구성할 수 있다.
	1.	임무계획 서비스(MPS) 가 촬영계획 완료 후 “MissionPlanCompleted” 이벤트를 발행한다.
	2.	비행역학 서비스(FDS) 는 해당 이벤트를 구독하여 궤도 예측을 수행하고, 결과를 “OrbitUpdated” 이벤트로 발행한다.
	3.	임무운용 서비스(SOS) 는 궤도 갱신 이벤트를 수신하여 명령을 생성·송신한다.
	4.	직저장 서비스(DIS) 는 “DownlinkStart” 이벤트를 구독하여 데이터 수신을 개시한다.
	5.	영상처리 서비스(PMS) 는 “DataReceived” 이벤트를 받아 영상 처리 절차를 자동으로 수행한다.

이러한 이벤트 기반 구조를 통해 각 서비스의 역할이 명확히 분리되고, 시스템 전체 운용 절차가 자동화된다.
또한 메시지 브로커가 큐잉(Buffer) 역할을 수행하므로 데이터 처리량이 급증하더라도 안정적인 처리가 가능하다.
결과적으로 제안된 통신 구조는 낮은 결합도(Loose Coupling) 와 높은 연동성(Easy Integration) 을 동시에 실현하여, 새로운 위성 또는 기능 추가 시에도 별도의 코드 수정 없이 이벤트 구독만으로 간단히 통합이 가능하다.

### 제안 오프소스 및 기술 스택

| 구분       | 기술명                                 | 주요 기능                 |
| -------- | ----------------------------------- | --------------------- |
| 메시지 브로커  | RabbitMQ, Apache Kafka, NATS        | 비동기 이벤트 처리 및 스트리밍 지원  |
| 워크플로우 엔진 | Apache Airflow, Temporal, Celery    | 이벤트 기반 프로세스 제어 및 스케줄링 |
| 메시지 포맷   | Protocol Buffers, Avro, JSON Schema | 서비스 간 표준화된 데이터 구조 정의  |
